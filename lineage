#!/usr/bin/env bash
self_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if [ $# -lt 1 ];then
  echo "Usage: $0 <crossplane xrd type>/<name>" >&2
  echo "       $(echo $0|sed 's/./ /g') <crossplane claim type>/<name>" >&2
  echo "       $(echo $0|sed 's/./ /g') <crossplane claim type | xrd type >" >&2
  exit -1
fi

if [ "$1" == "--version" ];then
  echo "Version: 1.0"
  exit 0
fi

if [ -z $CACHEDIR ];then
  export CACHEDIR=$(mktemp -d)
  trap "rm -fr $CACHEDIR" EXIT
fi

CRDCACHE=$CACHEDIR/crds.json
XRDCACHE=$CACHEDIR/xrds.json
OTHERCACHE=$CACHEDIR/other.json

if [ ! -f $CRDCACHE ];then
  kubectl get crds -o json >$CRDCACHE &
fi

if [ ! -f $XRDCACHE ];then
  kubectl get compositeresourcedefinitions.apiextensions.crossplane.io -o json >$XRDCACHE &
fi

if [ ! -f $OTHERCACHE ];then
  echo '{}' >$OTHERCACHE
fi

find_valid_kind() {
  if kubectl get $KIND/$NAME >/dev/null; then
    echo $KIND
    return 0
  fi
  for group in $(jq -r ".${KIND} // empty" $OTHERCACHE) $(jq -r '.items[].spec|select(.names.kind|ascii_downcase == "'${KIND,,}'").group' $CRDCACHE);do
    crd=${KIND}.${group}
    if kubectl get $crd $NAME >/dev/null;then
      jq <$OTHERCACHE '.+ {"'${KIND}'":"'${group}'"}'|sponge $OTHERCACHE
      echo $crd
      return 0
    fi
  done
}

get_resource() {
  RES=$(echo "$@" |grep -o '[[:alnum:]._-]*/[[:alnum:]._-]*')
  KIND=${RES%%/*}
  NAME=${RES##*/}
}

FIRST="$1";shift

if [ "$FIRST" == "___FZF_ENTER" ];then
  clear
  set -x
  get_resource "$1"
  crd=$(find_valid_kind)
  kubectl describe $crd $NAME |less
elif [ "$FIRST" == "___FZF_PREVIEW" ];then
  get_resource "$1"
  if [ "$KIND" == "Object" ];then
    kubectl -o json get $KIND/$NAME|jq -r '.spec.forProvider.manifest | ""+.kind+"/"+.metadata.name+"@"+.metadata.namespace'
  elif [ "$KIND" == "Release" ];then
    kubectl -o json get $KIND/$NAME|jq -r '.spec.forProvider|.chart.name+"@"+.namespace'
  elif [ "$KIND" == "Dependency" ];then
    dependee=$(kubectl -o json get $KIND/$NAME|jq -r '.metadata.labels.dependsOn')
    kubectl -o json get Dependency/${dependee}|jq -r '.metadata.ownerReferences[]|"" + .kind + "/" + .name'
  else
    echo "No preview available.....(suggest one)"
  fi
elif [ "$FIRST" == "___FZF_EDIT" ];then
  clear
  CLAIM=$1
  get_resource "$CLAIM"
  crd=$(find_valid_kind)
  kubectl edit $crd $NAME
elif [ "$FIRST" == "___FZF_DELETE" ];then
  clear
  RES=$1
  get_resource "$RES"
  crd=$(find_valid_kind)
  CLAIMJ=$(kubectl get $crd $NAME -o json|jq '.spec.claimRef')
  if [ "$CLAIMJ" != "null" ];then
    CLAIMKIND=$(echo $CLAIMJ|jq -r '.kind')
    CLAIMNAME=$(echo $CLAIMJ|jq -r '.name')
    CLAIMAPI=$(echo $CLAIMJ|jq -r '.apiVersion')
    CLAIMAPI=${CLAIMAPI%%/*}
    TEXT="You are trying to delete a Composite resource $crd/$NAME, although it has a claim ${CLAIMKIND}.${CLAIMAPI}/${CLAIMNAME}!\nDo you want to delete the claim instead?"
    if dialog --yesno "$TEXT" 7 $[ ($(echo -e $TEXT|head -1|wc -c)) +3 ];then
      echo kubectl delete ${CLAIMKIND}.${CLAIMAPI}/${CLAIMNAME} -n $(echo $CLAIMJ|jq -r '.namespace') 2>&1| less
      exit 0
    fi
  fi
  TEXT="Are you sure you want to delete $crd/$NAME?"
  if dialog --yesno "$TEXT" 5 $[ $(echo $TEXT|wc -c) +3 ];then
    kubectl delete $crd $NAME 2>&1| less
  fi
elif [ "$FIRST" == "___FZF_YAML" ];then
  clear
  CLAIM=$1
  get_resource "$CLAIM"
  crd=$(find_valid_kind)
  kubectl get -o yaml $crd $NAME | less
elif [ "$FIRST" == "___FZF_COMPOSITION" ];then
  clear
  CLAIM=$1
  get_resource "$CLAIM"
  crd=$(find_valid_kind)
  kubectl -o yaml get compositionrevision $(kubectl -o json get $crd/$NAME|jq -r '.spec.compositionRevisionRef.name') | less 
elif [ "$FIRST" == "___FZF_DEFAULT" ];then
  date
  CLAIM=$1
  get_resource "$CLAIM"
  shift
  RES=$(kubectl get $KIND -o json -A|jq -r '.items[]|select(.metadata.name=="'$NAME'").spec.resourceRef|.kind+"/"+.name')
  if [ "$RES" == "/" ];then 
    RES="$CLAIM"
  fi
  kubectl lineage --exclude-types Event,ProviderConfigUsage.aws,ProviderConfigUsage.tf,ProviderConfigUsage.helm,ProviderConfigUsage.kubernetes "$RES" "$@"
else
  get_resource "$FIRST"
  if [ -z $RES -a -z $KIND ];then
    FZF_DEFAULT_COMMAND="kubectl get $FIRST -A -o name" \
    fzf --layout=reverse  \
    --bind 'enter:execute('$0' {})+abort'
  else
    FZF_DEFAULT_COMMAND="$0 ___FZF_DEFAULT $FIRST $@" \
    fzf --no-mouse --header-lines=2 --layout=reverse \
    --preview "$0 ___FZF_PREVIEW {}" \
    --preview-window up:1:hidden:wrap \
    --bind 'enter:execute('$0' ___FZF_ENTER {}),ctrl-q:abort,ctrl-r:reload(eval "$FZF_DEFAULT_COMMAND"),ctrl-p:toggle-preview,ctrl-e:execute('$0' ___FZF_EDIT {}),ctrl-y:execute('$0' ___FZF_YAML {}),ctrl-x:execute('$0' ___FZF_DELETE {}),ctrl-o:execute('$0' ___FZF_COMPOSITION {})' \
    --header 'CTRL-Q: Quit, ENTER: Describe resource, CTRL-Y: Get Yaml, CTRL-E: Edit resource, CTRL-X: Delete resource, CTRL-O: Show the actual composition, CTRL-R: Reload, CTRL-P: Object preview'
    clear
  fi
fi
